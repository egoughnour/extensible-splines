import matplotlib.pyplot as plt
from matplotlib.backend_bases import MouseEvent
from typing import TypeVar, Generic
import splines
import math

SplineType = TypeVar('SplineType', bound=splines.BaseSpline)
# SplineEditor, enables click and drag editing of knots, visualization of the series of knots and of the path generated by them
class SplineEditor(Generic[SplineType]):
    """click and drag spline knot editor"""
    def __init__(self, spline: SplineType, point_click_distance_min=3.0, points_per_segment=20, interpolant_fmt: str="b", knot_line_fmt: str="a") -> None:
        self.figure = None
        self.axes = None
        self.line = None
        self.interpolant = splines.Interpolant(spline)
        self.points = {}
        self.knot_line = None
        self.click_epsilon_dist = point_click_distance_min
        self.points_per_segment = points_per_segment
        self.interpolant_fmt = interpolant_fmt
        self.knot_line_fmt = knot_line_fmt
        self.extent: tuple[int,int] = None
        self.knot_moving = None
        #TODO decide whether to init figure, axes, handlers in init. Probably should separate this

    def init_figure(self, caption:str, extent:tuple[int,int] = (100,100)) -> None:
        """initialize figure and show"""
        self.extent = extent
        self.figure = plt.figure(caption)
        self.axes = plt.subplot()
        self.axes.set_xlim(0, extent[0])
        self.axes.set_ylim(0, extent[1])
        self.axes.set_aspect('equal')
        self.axes.set_title('Click and drag to edit knots')
        self.axes.set_xlabel('x')
        self.axes.set_ylabel('y')
        self.axes.grid(which='both')
        self.figure.canvas.mpl_connect('button_press_event', self.on_click)
        self.figure.canvas.mpl_connect('button_release_event', self.on_release)
        self.figure.canvas.mpl_connect('motion_notify_event', self.on_motion)
        plt.show()

    def add_knot(self, x, y=None):
        if isinstance(x, MouseEvent):
            x, y = int(x.xdata), int(x.ydata)
        self.points[x] = y
        self.interpolant.spline.set_control_points(self.points)
        return x, y
    
    def remove_knot(self, x, _):
        if x in self.points:
            #TODO check del versus pop()?
            del self.points[x]
            self.interpolant.spline.set_control_points(self.points)

    def on_click(self, event):
        #check that we have left click and are in the axes
        #TODO check equality works here instead?
        if event.button == 1 and event.inaxes in [self.axes]:
            point = self.get_nearest_point(event)
            if point:
                # we found a point so we're moving it
                self.knot_moving = point
            else:
                self.add_knot(event)
            self.update_graph()
        elif event.button == 3 and event.inaxes in [self.axes]:
            point = self.get_nearest_point(event)
            if point:
                self.remove_knot(*point)
                self.update_graph()

    def update_graph(self) -> None:
        #if no points are defined, clear the line data.
        #otherwise if the minimum number of points is defined,
        #update the line data with the interpolant and the knot_line data with the knots (i.e, the points)
        #let the interpolant.spline determine the minimum number of points needed.
        # interpolant will determine rotation (if any)
        if not self.points:
            self.line.set_data([], [])
            self.knot_line.set_data([], [])
        else:
            if len(self.points) >= self.interpolant.spline.min_points_needed:
                theta = self.interpolant.rotation_angle
                # first get the interpolant and knot data
                # then if self.line is not defined, plot to create it and the line tracing out the knots
                # otherwise update the line data with the interpolant and the knot_line data with the knots (i.e, the points)
                # finally draw
                x, y = zip(*self.interpolant.get_all_points_all_segments(self.points_per_segment, theta))
                x_knot, y_knot = zip(*list(self.points.items()))
                if not self.line:
                    self.line, = self.axes.plot(x, y, self.interpolant_fmt)
                    line_between_knots, = self.axes.plot(x_knot, y_knot, self.knot_line_fmt)
                    self.knot_line = self.axes.add_line(line_between_knots)
                else:
                    self.line.set_data(x, y)
                    self.knot_line.set_data(x_knot, y_knot)
        self.figure.canvas.draw()

    def on_motion(self, event):
        if not self.knot_moving:
            return
        if event.xdata is None or event.ydata is None:
            return
        self.remove_knot(*self.knot_moving)
        self.knot_moving = self.add_knot(event)
        self.update_graph()

    def on_release(self, event):
        if event.button == 1 and event.inaxes in [self.axes] and self.knot_moving:
            self.knot_moving = None
            self.update_graph()

    def get_nearest_point(self, event):
        nearest_point = None
        # initially set the minimum distance so that it is larger than any possible point
        # this will vary given the extent of the plot/figure/axes
        min_distance_found = math.hypot(self.extent[0], self.extent[1])
        for x,y in self.points.items():
            dist = math.hypot(event.xdata - x, event.ydata - y)
            if dist < min_distance_found:
                min_distance_found = dist
                nearest_point = (x,y)
        if dist < self.click_epsilon_dist:
            return nearest_point
        return None